# -*- coding: utf-8 -*-
"""Untitled25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cur82j5f2O50XXsK5bhCF7KB1qlnBY6U
"""

# -*- coding: utf-8 -*-
"""
Aplicaci√≥n Streamlit para la Predicci√≥n de Demanda de Transporte.

Esta aplicaci√≥n carga un modelo de red neuronal entrenado con PyTorch para predecir el n√∫mero de asientos vendidos
en un viaje.
"""

import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import pandas as pd
import joblib # Importar joblib para cargar el preprocesador
from pathlib import Path
from datetime import datetime

# --- 1. DEFINICI√ìN DE LA ARQUITECTURA DEL MODELO ---
# Esta arquitectura DEBE ser id√©ntica a la que usaste para entrenar el modelo.

class DemandPredictionNet(nn.Module):
    def __init__(self, n_input_features):
        super().__init__()
        self.layers = nn.Sequential(
            nn.Linear(n_input_features, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 16),
            nn.ReLU(),
            nn.Linear(16, 1)
        )

    def forward(self, x):
        return self.layers(x)

# --- 2. FUNCI√ìN PARA CARGAR EL MODELO Y EL PREPROCESADOR ---
@st.cache_resource
def load_model_and_preprocessor():
    """
    Carga el modelo de PyTorch (estado) y el preprocesador (joblib).
    """
    # Rutas a los archivos del modelo y preprocesador
    model_state_path = Path(__file__).parent / "modelo_pytorch123.pth"
    preprocessor_path = Path(__file__).parent / "preprocesador123.pkl"

    if not model_state_path.exists():
        st.error(f"Error: No se encontr√≥ el archivo del estado del modelo en la ruta: {model_state_path}")
        st.error("Aseg√∫rate de que 'modelo_pytorch123.pth' est√© en el mismo directorio que este script.")
        return None, None

    if not preprocessor_path.exists():
        st.error(f"Error: No se encontr√≥ el archivo del preprocesador en la ruta: {preprocessor_path}")
        st.error("Aseg√∫rate de que 'preprocesador123.pkl' est√© en el mismo directorio que este script.")
        return None, None

    try:
        # Cargar el preprocesador con joblib
        preprocessor = joblib.load(preprocessor_path)

        # Determinar el n√∫mero de caracter√≠sticas de entrada a partir del preprocesador
        # Esto asume que el preprocesador tiene un atributo 'n_features_in_' o similar
        # o que puedes deducirlo de los datos de entrenamiento usados para crearlo.
        # En tu script de entrenamiento, 'input_features' se defini√≥ como X_train_processed.shape[1]
        # Para obtenerlo de un preprocesador ya entrenado, puedes necesitar un peque√±o truco
        # o guardar este valor junto con el preprocesador.
        # Una forma es pasar un dummy input a trav√©s del preprocesador para ver la forma de salida.
        # Sin embargo, la forma m√°s robusta es guardar 'input_features' junto con el preprocesador.
        # Si no lo guardaste, puedes intentar inferirlo de la transformaci√≥n de un dataframe vac√≠o
        # o simplemente usar un valor fijo si sabes que no cambiar√°.
        # Para este ejemplo, asumiremos que el preprocesador puede inferir las caracter√≠sticas
        # o que 'input_features' se conoce. Si no, necesitar√≠as guardar este valor en el .pkl
        # o en un archivo separado.

        # Una forma de obtener n_input_features si no se guard√≥ expl√≠citamente:
        # Crea un DataFrame dummy con las columnas esperadas por el preprocesador
        # y luego transforma para obtener la forma.
        dummy_data = pd.DataFrame([[0, 0, 0, 0, 'Lugar_A', 'Lugar_B', 'bus', 'efectivo']],
                                  columns=['cupo_max', 'dia_semana', 'mes', 'hora',
                                           'origen', 'destino', 'tipo_carro', 'metodo_pago'])
        input_features = preprocessor.transform(dummy_data).shape[1]


        # Instanciar el modelo con el n√∫mero correcto de caracter√≠sticas de entrada
        model = DemandPredictionNet(n_input_features=input_features)

        # Cargar el estado del modelo PyTorch
        model.load_state_dict(torch.load(model_state_path, map_location=torch.device('cpu')))
        model.eval() # Poner el modelo en modo de evaluaci√≥n

        return model, preprocessor

    except Exception as e:
        st.error(f"Ocurri√≥ un error al cargar el modelo o el preprocesador: {e}")
        st.error("Aseg√∫rate de que los archivos .pth y .pkl no est√©n corruptos y que las versiones de las librer√≠as sean compatibles.")
        return None, None

# --- 3. CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(
    page_title="Predicci√≥n de Demanda de Transporte",
    page_icon="üöå",
    layout="wide"
)
st.title("üöå Predicci√≥n Inteligente de Demanda de Transporte")
st.markdown("""
¬°Bienvenido a la herramienta definitiva para optimizar tus rutas de transporte!
Esta aplicaci√≥n innovadora utiliza un **modelo avanzado de Red Neuronal (PyTorch)**
para predecir con alta precisi√≥n el n√∫mero de asientos que se vender√°n en cada viaje.
Anticipa la demanda, maximiza la ocupaci√≥n y mejora la eficiencia de tus operaciones.
""")

# Botones de informaci√≥n
st.markdown("---")
col_info1, col_info2 = st.columns(2)
with col_info1:
    st.link_button("üé• ¬øC√≥mo usar?", url="https://www.youtube.com/watch?v=tu_video_de_ejemplo", help="Haz clic para ver un video tutorial") # Reemplaza con tu link de video
with col_info2:
    st.link_button("üìÑ Reporte T√©cnico", url="https://tu_blog_o_documento_tecnico.com", help="Haz clic para leer el informe t√©cnico detallado") # Reemplaza con tu link de blog
st.markdown("---")


# --- 4. CARGAR MODELO Y PREPROCESADOR ---
model, preprocessor = load_model_and_preprocessor()

if model is None or preprocessor is None:
    st.stop()
else:
    st.success("‚úÖ Modelo y preprocesador cargados exitosamente.")

# --- 5. FORMULARIO DE ENTRADA ---
with st.form("formulario_prediccion_demanda"):
    st.subheader("üìã Ingrese los Datos del Viaje")

    # Opciones basadas en tu script de entrenamiento
    ciudades = ['Lugar_A', 'Lugar_B', 'Lugar_C', 'Lugar_D', 'Lugar_E']
    car_types = ['bus', 'minibus', 'van']
    metodos_pago = ['efectivo', 'transferencia', 'tarjeta de credito']

    col1, col2, col3 = st.columns(3)

    with col1:
        st.write("#### üó∫Ô∏è Ruta")
        origen = st.selectbox("Origen", options=ciudades, index=0)
        destino = st.selectbox("Destino", options=ciudades, index=1)

    with col2:
        st.write("#### üìÖ Fecha y Hora")
        fecha_viaje = st.date_input("Fecha del viaje", value=datetime.now())
        hora_viaje = st.time_input("Hora del viaje", value=datetime.now().time())

    with col3:
        st.write("#### ‚öôÔ∏è Detalles del Veh√≠culo y Pago")
        tipo_carro = st.selectbox("Tipo de veh√≠culo", options=car_types, index=0)
        cupo_max = st.number_input("Cupo m√°ximo del veh√≠culo", min_value=1, value=30, step=1)
        metodo_pago = st.selectbox("M√©todo de pago principal", options=metodos_pago, index=0)

    # Bot√≥n para enviar el formulario
    enviado = st.form_submit_button("Predecir Demanda")


# --- 6. PROCESAMIENTO Y PREDICCI√ìN ---
if enviado:
    # Validaci√≥n simple
    if origen == destino:
        st.error("El origen y el destino no pueden ser el mismo lugar. Por favor, corr√≠gelo.")
    else:
        # Ingenier√≠a de caracter√≠sticas a partir de las entradas del usuario
        dia_semana = fecha_viaje.weekday()  # Lunes=0, Domingo=6
        mes = fecha_viaje.month
        hora = hora_viaje.hour

        # Crear un DataFrame con una sola fila para la predicci√≥n
        # El orden de las columnas DEBE ser el mismo que en el entrenamiento
        columnas_features = [
            'cupo_max', 'dia_semana', 'mes', 'hora', # Num√©ricas
            'origen', 'destino', 'tipo_carro', 'metodo_pago' # Categ√≥ricas
        ]
        input_data = pd.DataFrame([[
            cupo_max, dia_semana, mes, hora,
            origen, destino, tipo_carro, metodo_pago
        ]], columns=columnas_features)

        try:
            # Aplicar el preprocesador (escala y one-hot encode)
            input_processed = preprocessor.transform(input_data)

            # Convertir a tensor de PyTorch
            input_tensor = torch.tensor(input_processed, dtype=torch.float32)

            # Realizar la predicci√≥n
            with torch.no_grad():
                prediccion_cruda = model(input_tensor)
                # El modelo devuelve un tensor, extraemos el valor num√©rico
                asientos_predichos = prediccion_cruda.item()

            # Redondear al entero m√°s cercano, ya que no se pueden vender fracciones de asiento
            asientos_predichos_redondeado = round(asientos_predichos)

            # Asegurarse de que la predicci√≥n no exceda el cupo m√°ximo
            asientos_final = min(asientos_predichos_redondeado, cupo_max)
            asientos_final = max(0, asientos_final) # Y que no sea negativa

            # --- Mostrar el resultado ---
            st.markdown("---")
            st.subheader("üìà Resultado de la Predicci√≥n")
            col_res1, col_res2 = st.columns(2)

            with col_res1:
                st.metric(
                    label="Asientos a Vender (Estimado)",
                    value=f"{asientos_final} asientos"
                )
                porcentaje_ocupacion = (asientos_final / cupo_max) * 100 if cupo_max > 0 else 0
                st.metric(
                    label="Ocupaci√≥n Estimada",
                    value=f"{porcentaje_ocupacion:.2f} %"
                )

            with col_res2:
                st.write("Nivel de Ocupaci√≥n:")
                st.progress(int(porcentaje_ocupacion))
                if porcentaje_ocupacion > 85:
                    st.success("¬°Alta demanda esperada! El viaje probablemente se llenar√°.")
                elif porcentaje_ocupacion > 50:
                    st.info("Demanda moderada. Se espera una buena ocupaci√≥n.")
                else:
                    st.warning("Demanda baja. Considere estrategias para aumentar las ventas.")

            with st.expander("Ver detalles t√©cnicos de la predicci√≥n"):
                st.write("**Datos de Entrada (Post-Procesamiento):**")
                st.dataframe(input_data)
                st.write(f"**Salida cruda del modelo:** `{asientos_predichos:.4f}`")
                st.write(f"**Predicci√≥n redondeada:** `{asientos_predichos_redondeado}`")
                st.write(f"**Predicci√≥n final (ajustada a cupo):** `{asientos_final}`")


        except Exception as e:
            st.error(f"Ocurri√≥ un error durante la predicci√≥n: {e}")
            st.error("Aseg√∫rate de que el archivo '.pkl' no est√© corrupto y que las entradas sean v√°lidas.")