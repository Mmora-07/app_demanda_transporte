# -*- coding: utf-8 -*-
"""Untitled25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cur82j5f2O50XXsK5bhCF7KB1qlnBY6U
"""

# -*- coding: utf-8 -*-
"""
Aplicaci√≥n Streamlit para la Predicci√≥n de Demanda de Transporte.

Esta aplicaci√≥n carga un modelo de red neuronal entrenado con PyTorch y un
preprocesador de Scikit-learn para predecir el n√∫mero de asientos vendidos
en un viaje.
"""

import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import pandas as pd
import pickle
from pathlib import Path
from datetime import datetime

# --- 1. DEFINICI√ìN DE LA ARQUITECTURA DEL MODELO ---
# Esta arquitectura DEBE ser id√©ntica a la que usaste para entrenar el modelo.

class DemandPredictionNet(nn.Module):
    def __init__(self, n_input_features):
        super().__init__()
        self.layers = nn.Sequential(
            nn.Linear(n_input_features, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 16),
            nn.ReLU(),
            nn.Linear(16, 1)
        )

    def forward(self, x):
        return self.layers(x)

# --- 2. FUNCI√ìN PARA CARGAR EL MODELO Y EL PREPROCESADOR ---
@st.cache_resource
def load_model_and_preprocessor():
    """
    Carga el modelo de PyTorch y el preprocesador desde el archivo .pkl.
    """
    model_path = Path(__file__).parent / "demand_prediction_redN.pkl"

    if not model_path.exists():
        st.error(f"Error: No se encontr√≥ el archivo del modelo en la ruta: {model_path}")
        st.error("Aseg√∫rate de que 'demand_prediction_redN.pkl' est√© en el mismo directorio que este script.")
        return None, None

    with open(model_path, 'rb') as f:
        deployment_package = pickle.load(f)

    # Reconstruir el modelo
    input_features = deployment_package['input_features']
    model = DemandPredictionNet(n_input_features=input_features)
    model.load_state_dict(deployment_package['model_state_dict'])
    model.eval() # Poner el modelo en modo de evaluaci√≥n

    # Extraer el preprocesador
    preprocessor = deployment_package['preprocessor']

    return model, preprocessor

# --- 3. CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(
    page_title="Predicci√≥n de Demanda de Transporte",
    page_icon="ÔøΩ",
    layout="wide"
)
st.title("üöå Sistema de Predicci√≥n de Demanda de Transporte")
st.markdown("Ingrese los detalles del viaje para estimar el n√∫mero de asientos que se vender√°n.")
st.markdown("---")

# --- 4. CARGAR MODELO Y PREPROCESADOR ---
model, preprocessor = load_model_and_preprocessor()

if model is None or preprocessor is None:
    st.stop()
else:
    st.success("‚úÖ Modelo cargados exitosamente.")

# --- 5. FORMULARIO DE ENTRADA ---
with st.form("formulario_prediccion_demanda"):
    st.subheader("üìã Ingrese los Datos del Viaje")

    # Opciones basadas en tu script de entrenamiento
    ciudades = ['Lugar_A', 'Lugar_B', 'Lugar_C', 'Lugar_D', 'Lugar_E']
    car_types = ['bus', 'minibus', 'van']
    metodos_pago = ['efectivo', 'transferencia', 'tarjeta de credito']

    col1, col2, col3 = st.columns(3)

    with col1:
        st.write("#### üó∫Ô∏è Ruta")
        origen = st.selectbox("Origen", options=ciudades, index=0)
        destino = st.selectbox("Destino", options=ciudades, index=1)

    with col2:
        st.write("#### üìÖ Fecha y Hora")
        fecha_viaje = st.date_input("Fecha del viaje", value=datetime.now())
        hora_viaje = st.time_input("Hora del viaje", value=datetime.now().time())

    with col3:
        st.write("#### ‚öôÔ∏è Detalles del Veh√≠culo y Pago")
        tipo_carro = st.selectbox("Tipo de veh√≠culo", options=car_types, index=0)
        cupo_max = st.number_input("Cupo m√°ximo del veh√≠culo", min_value=1, value=30, step=1)
        metodo_pago = st.selectbox("M√©todo de pago principal", options=metodos_pago, index=0)

    # Bot√≥n para enviar el formulario
    enviado = st.form_submit_button("Predecir Demanda")


# --- 6. PROCESAMIENTO Y PREDICCI√ìN ---
if enviado:
    # Validaci√≥n simple
    if origen == destino:
        st.error("El origen y el destino no pueden ser el mismo lugar. Por favor, corr√≠gelo.")
    else:
        # Ingenier√≠a de caracter√≠sticas a partir de las entradas del usuario
        dia_semana = fecha_viaje.weekday()  # Lunes=0, Domingo=6
        mes = fecha_viaje.month
        hora = hora_viaje.hour

        # Crear un DataFrame con una sola fila para la predicci√≥n
        # El orden de las columnas DEBE ser el mismo que en el entrenamiento
        columnas_features = [
            'cupo_max', 'dia_semana', 'mes', 'hora', # Num√©ricas
            'origen', 'destino', 'tipo_carro', 'metodo_pago' # Categ√≥ricas
        ]
        input_data = pd.DataFrame([[
            cupo_max, dia_semana, mes, hora,
            origen, destino, tipo_carro, metodo_pago
        ]], columns=columnas_features)

        try:
            # Aplicar el preprocesador (escala y one-hot encode)
            input_processed = preprocessor.transform(input_data)

            # Convertir a tensor de PyTorch
            input_tensor = torch.tensor(input_processed, dtype=torch.float32)

            # Realizar la predicci√≥n
            with torch.no_grad():
                prediccion_cruda = model(input_tensor)
                # El modelo devuelve un tensor, extraemos el valor num√©rico
                asientos_predichos = prediccion_cruda.item()

            # Redondear al entero m√°s cercano, ya que no se pueden vender fracciones de asiento
            asientos_predichos_redondeado = round(asientos_predichos)

            # Asegurarse de que la predicci√≥n no exceda el cupo m√°ximo
            asientos_final = min(asientos_predichos_redondeado, cupo_max)
            asientos_final = max(0, asientos_final) # Y que no sea negativa

            # --- Mostrar el resultado ---
            st.markdown("---")
            st.subheader("üìà Resultado de la Predicci√≥n")
            col_res1, col_res2 = st.columns(2)

            with col_res1:
                st.metric(
                    label="Asientos a Vender (Estimado)",
                    value=f"{asientos_final} asientos"
                )
                porcentaje_ocupacion = (asientos_final / cupo_max) * 100 if cupo_max > 0 else 0
                st.metric(
                    label="Ocupaci√≥n Estimada",
                    value=f"{porcentaje_ocupacion:.2f} %"
                )

            with col_res2:
                st.write("Nivel de Ocupaci√≥n:")
                st.progress(int(porcentaje_ocupacion))
                if porcentaje_ocupacion > 85:
                    st.success("¬°Alta demanda esperada! El viaje probablemente se llenar√°.")
                elif porcentaje_ocupacion > 50:
                    st.info("Demanda moderada. Se espera una buena ocupaci√≥n.")
                else:
                    st.warning("Demanda baja. Considere estrategias para aumentar las ventas.")

            with st.expander("Ver detalles t√©cnicos de la predicci√≥n"):
                st.write("**Datos de Entrada (Post-Procesamiento):**")
                st.dataframe(input_data)
                st.write(f"**Salida cruda del modelo:** `{asientos_predichos:.4f}`")
                st.write(f"**Predicci√≥n redondeada:** `{asientos_predichos_redondeado}`")
                st.write(f"**Predicci√≥n final (ajustada a cupo):** `{asientos_final}`")


        except Exception as e:
            st.error(f"Ocurri√≥ un error durante la predicci√≥n: {e}")
            st.error("Aseg√∫rate de que el archivo '.pkl' no est√© corrupto y que las entradas sean v√°lidas.")